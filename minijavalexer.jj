options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)


// Insert a specification of a lexical analysis here.
TOKEN:
{
  < LPAREN: "(" >
  | < RPAREN: ")" >
  | < LCOUCH: "[" >
  | < RCOUCH: "]" >
  | < VIRG: "," >
  | < DOT: "." >
  | < EQ: "=" >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < SEMICOLON: ";" >
  | < LESS: "<" >
  | < NOT: "!" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < STAR: "*" >
  | < AND: "&&" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < WHILE: "while" >
  | < NEW: "new" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < LENGTH: "length" >
  | < THIS: "this" >
  | < VOID: "void" >
  | < PRINT: "System.out.println" >
  | < BOOLEAN: "boolean" >
  | < INTEGER: "int" >
  | < STRING: "String" >
  | < STATIC: "static" >
  | < EXTENDS: "extends" >
  | < RETURN: "return" >
  | < CLASS: "class" >
  | < PUBLIC: "public" >
  | < MAIN: "main" >
  | < IDENTIFIER: (< LETTER >) (< LETTER >| < DIGIT >)* >
  | < #DIGIT: ["0" - "9"] >
  | < #LETTER: ["a" - "z"] | ["A" - "Z"] | "_" >
  | < INTEGER_LITERAL: (< DIGIT >)+ >
}
SKIP:
{
	< "//" (" ")* (["a" - "z","A" - "Z","0" - "9"," ","_",";"])* "\n" >
	| < "/*" (["a" - "z","A" - "Z","0" - "9"])* "*/" >
	| < " " >
	| < "\n" >
	| < "\t" >
}
    
 
// The following is a simple grammar that will allow you
// to test the generated lexer.

//Grammar available on: http://www.cambridge.org/resources/052182060X/MCIIJ2e/grammar.htm

Program Prog() :
{
	MainClass m;
	ClassDeclList cl;
}
{ m = MainClass() cl = ClassDeclList() {return new Program(m,cl);} }

MainClass MainClass() :
{
	Identifier i1,i2;
  	Statement s;
}
{ < CLASS > i1 = Identifier() < LBRACE > 
  < PUBLIC > < STATIC > < VOID > < MAIN > < LPAREN > < STRING > < LCOUCH > < RCOUCH > i2 = Identifier() < RPAREN > < LBRACE > s = Stm() < RBRACE > < RBRACE > 
  
{return new MainClass(i1,i2,s); } }

ClassDeclList ClassDeclList() :
{
	ClassDeclList cl = new ClassDeclList();
	ClassDecl c;
}
{ (c = ClassDeclOp() { cl.addElement(c); })* 
{return cl;}}

ClassDecl ClassDeclOp() :
{
	ClassDecl c;
}
{ (c = ClassDeclarationSimple() | c = ClassDeclarationExtends())
{return c;} }



ClassDecl ClassDeclSimple() : 
 	{ Identifier i; VarDeclList v = new VarDeclList(); MethodDeclList m = new MethodDeclList();} 
 	{ <CLASS> i=Identifier() 
 		<LBRACE> [ v=VarDeclList() ] [ m=MethodDeclList() ] <RBRACE> { return new ClassDeclSimple(i, v, m); } 
 	} 	

ClassDecl ClassDeclExtends() : 
 	{ Identifier i1, i2; VarDeclList v = new VarDeclList(); MethodDeclList m = new MethodDeclList();} 
 	{ <CLASS> i1=Identifier() <EXTENDS> i2=Identifier() 
 		<LBRACE> [ v=VarDeclList() ] [ m=MethodDeclList() ] <RBRACE> { return new ClassDeclExtends(i1, i2, v, m); } 
 	}

VarDeclList VarDeclList() :
{
	VarDeclList vl = new VarDeclList();
	VarDecl v;
}
{ (LOOKAHEAD(2) v = VarDeclaration() {vl.addElement(v);})*
	
{return vl;}}

VarDecl VarDeclaration() :
{
	Type t;
  	Identifier i;
}
{ t = Type() i = Identifier() < SEMICOLON > 

{return new VarDecl(t,i);}}

MethodDeclList MethodDeclList() :
{
	MethodDeclList ml = new MethodDeclList();
	MethodDecl m;
}
{ (m = MethodDeclaration() {ml.addElement(m);})*
	
{return ml;}}

MethodDecl MethodDeclaration() :
{
	Type t;
	Identifier i;
	FormalList fl;
	VarDeclList vl;
	StatementList sl;
	Exp e;
}
{ < PUBLIC > t = Type() i = Identifier() < LPAREN > (fl = FormalList())? < RPAREN > < LBRACE > (LOOKAHEAD(2) vl = VarDeclaration()) (sl = StatementList()) < RETURN > e = Exp() < SEMICOLON > < RBRACE > 

{return new MethodDeclaration(t,i,fl,vl,sl);}}

FormalList FormalList() :
{
	FormalList fl = new FormalList();
	Formal f;
}
{ (f = Formal() {fl.addElement(f);} (< VIRG > f = Formal() {fl.addElement(f);})*)

}

Formal Formal() :
{
	Type t;
  	Identifier i;
}
{ t = Type() i = Identifier()

{return new Formal(t,i);}}

Type Type() :
{
	Type t;
}
{ LOOKAHEAD(2) t = IntArrayType()
  | t = BooleanType()
  | LOOKAHEAD(2) t = IntegerType()
  | t = IdentifierType() 
  
{ return t; }}

IntArrayType IntArrayType() :
{
	Type t;
}
{ < INTEGER > < LCOUCH > < RCOUCH >

{return IntArrayType();}}

IntegerType IntegerType() :
{
	Type t;
}
{ < INTEGER > 

{return new IntegerType();}}
  
Type BooleanType() :
{}
{ < BOOLEAN >

{return new BooleanType();}}

Type IdentifierType() :
{
	i = Identifier();
}
{ i = Identifier()

{return new IdentifierType(i.s);}}

Identifier Identifier() :
{
	Token t;
}
{ t = < IDENTIFIER >

{return new Identifier(t.image);}}

 StatementList StatementList() : 
 	{ StatementList sl = new StatementList(); Statement s; } 
 	{ s=Statement() { sl.addElement(s); }
 		(s=Statement() {sl.addElement(s);} )* { return sl; } 
 	}

 Statement Stm() : 
 	{ Statement s; } 
 	{ (s=Block() | s=If() | s=Print() | s=While() | LOOKAHEAD(2) s=Assign() | s=ArrayAssign()) { return s; } 
 	}

Statement If() :
{
	Exp e;
	Statement s1,s2;	
}
{ < IF > < LPAREN > e = Exp() < RPAREN > s1 = Stm() < ELSE > s2 = Stm()
	
{return new If(e,s1,s2);}}

Statement While() :
{
	Exp e;
	Statement s;
}
{ < WHILE > < LPAREN > e = Exp() < RPAREN > s = Stm()

{return new While(s,e);}}

Statement Print() :
{
	Exp e;
}
{ < PRINT > < LPAREN > e = Exp() < RPAREN > < SEMICOLON >

{return new Print(e);}}

Statement Assign() :
{
	Identifier i;
	Exp e;
}
{ LOOKAHEAD(2) i = Identifier() < EQ > e = Exp() < SEMICOLON >

{return new Assign(i,e);}}

Statement ArrayAssign() :
{
	Identifier i;
	Exp e1,e2;
}
{ i = Identifier() < LCOUCH > e = Exp() < RCOUCH > < EQ > e = Exp() < SEMICOLON >

{return new ArrayAssign(i,e1,e2);}}


 Exp Exp() : 
 	{ Exp e;} 
 	{ e=And() { return e; } 
 	}
 Exp And() : 
 	{ Exp e1=null,e2=null; }
 	{ e1=LessThan() ( <AND> e2=LessThan() { return new And(e1, e2); } )* { return e1; }
 	}
 Exp LessThan() : 
 	{ Exp e1=null,e2=null; } 
	{ e1=AdditiveExp() [ <LESS> e2=AdditiveExp() { return new LessThan(e1, e2); } ] { return e1; }  
	}
 Exp AdditiveExp() : 
 	{ boolean usePlus = true; Exp e1=null,e2=null; } 
 	{ e1=Times() ( (<PLUS> {usePlus = true;} | <MINUS> {usePlus = false;})
 		 e2=Times() { if (usePlus) return new Plus(e1, e2); else return new Minus(e1, e2); })* { return e1; } 		 
 	} 
 Exp Times() : 
 	{ Exp e1=null,e2=null; } 
 	{ e1=PrefixExp() ( <STAR> e2=PrefixExp() { return new Times(e1, e2); } )* { return e1; }
 	}
 Exp PrefixExp() : 
 	{ Exp e1; } 
	{ (LOOKAHEAD(3) e1=Not() | e1=PostfixExp()) { return e1; } 
	}
 Exp Not() : 
 	{ Exp e1; boolean useNot = false; } 
 	{ [ <NOT> {useNot=true;} ] e1=PostfixExp() { if(useNot) return new Not(e1); else return e1; } 
 	}

 Exp PostfixExp() : 
 	{ Exp e1, e2; Identifier i; ExpList el = new ExpList() ; } 
 	{ e1=PrimaryExp() 
 		( <LBRACE> e2=Exp() <RBRACE>	{ return new ArrayLookup(e1, e2); }
 		| LOOKAHEAD(2) <DOT> i=Identifier() <LPAREN> [ el=ExpList() ] <RPAREN>	{ return new Call(e1, i, el); } 
 		| <DOT> <LENGTH> { return new ArrayLength(e1); } )* { return e1; }
	}

 /* Expressões primárias */
 Exp PrimaryExp() : 
 	{ Exp e; } 
 	{ ( e=IntegerLiteral() | e=True() | e=False() | e=AssociativeExp() | e=IdentifierExp() 
 		| e=This() | LOOKAHEAD(2) e=NewArray() | e=NewObject()) { return e; } 
 	}
 Exp IntegerLiteral() : 
 	{ Token t; } 
 	{ t=<INTEGER_LITERAL> { return new IntegerLiteral(Integer.parseInt(t.image)); } 
 	} 
 Exp True() : 
 	{} 
	{ <TRUE> { return new True(); } 
	}
 Exp False() : 
 	{} 
	{ <FALSE> { return new False(); } 
	} 
 Exp AssociativeExp() :
 	{ Exp e; }
	{ <LPAREN> e=Exp() <RPAREN> { return e; }	
	}
 Exp IdentifierExp() : 
 	{ Identifier i;} 
	{ i=Identifier() { return new IdentifierExp(i.s); } //not sure if this is right??? 
	} 
 Exp This() : 
 	{} 
 	{ <THIS> { return new This(); } 
 	}
 Exp NewArray() : 
 	{ Exp e; } 
 	{ <NEW> <INTEGER> <LBRACE> e=Exp() <RBRACE> { return new NewArray(e); }
 	}
 Exp NewObject() : 
 	{ Identifier i; } 
	{ <NEW> i=Identifier() <LPAREN> <RPAREN> { return new NewObject(i); }
	}

void Term() :
{}
{ < INTEGER_LITERAL >
  | < TRUE >
  | < FALSE >
  | Identifier()
  | < THIS >
  | LOOKAHEAD(2) < NEW > < INTEGER > < LCOUCH > Exp() < RCOUCH >
  | LOOKAHEAD(2) < NEW > Identifier() < LPAREN > < RPAREN >
  | < NOT > Exp()
  | < LPAREN > Exp() < RPAREN >}
  
void Op() :
{}
{
  < AND >
  | < LESS >
  | < PLUS >
  | < MINUS >
  | < STAR > }

void Goal() :
{}
{
  ( MiniJavaToken() )*
  <EOF>
}

void Start() :
{}
{
  ( Prog() )*
  <EOF>
}

void MiniJavaToken():
{}
{
  "class"  |  <IDENTIFIER> | "{" | "public" | "static" | "void" |
  "main" | "(" | "String"  | "[" | "]" | ")" | "}" | "extends" | ";"
  | "return" | "," | "int" | "boolean" | "=" | "if" | "else" | "while"
  | "System.out.println" | "&&" | "<" | "+" | "-" | "*" | "." |
  "length" | <INTEGER_LITERAL> | "true" | "false" | "this" | "new" |
  "!"
}


